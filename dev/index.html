<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MethodAnalysis.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MethodAnalysis.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Demonstrations"><span>Demonstrations</span></a></li><li><a class="tocitem" href="#API-reference"><span>API reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/MethodAnalysis.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MethodAnalysis.jl"><a class="docs-heading-anchor" href="#MethodAnalysis.jl">MethodAnalysis.jl</a><a id="MethodAnalysis.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MethodAnalysis.jl" title="Permalink"></a></h1><p>This package facilitates introspection of Julia&#39;s internals, with a particular focus on its MethodInstances and their backedges.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Julia&#39;s internals are not subject to the same interface compatibility guarantee that the rest of the language enjoys.</p></div></div><h2 id="Demonstrations"><a class="docs-heading-anchor" href="#Demonstrations">Demonstrations</a><a id="Demonstrations-1"></a><a class="docs-heading-anchor-permalink" href="#Demonstrations" title="Permalink"></a></h2><p>A few demonstrations will give you a taste of what can be done with this package.</p><h3 id="Collecting-all-submodules-of-Base"><a class="docs-heading-anchor" href="#Collecting-all-submodules-of-Base">Collecting all submodules of Base</a><a id="Collecting-all-submodules-of-Base-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-all-submodules-of-Base" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; using MethodAnalysis

julia&gt; mods = Module[];

julia&gt; visit(Base) do obj
           if isa(obj, Module)
               push!(mods, obj)
               return true     # descend into submodules
           end
           false   # but don&#39;t descend into anything else (MethodTables, etc.)
       end

julia&gt; Base.FastMath ∈ mods
true</code></pre><p>You can do this more easily with the convenience utility <a href="#MethodAnalysis.child_modules"><code>child_modules</code></a>.</p><h3 id="Collecting-all-Methods-of-functions-defined-in-Core.Compiler"><a class="docs-heading-anchor" href="#Collecting-all-Methods-of-functions-defined-in-Core.Compiler">Collecting all Methods of functions defined in Core.Compiler</a><a id="Collecting-all-Methods-of-functions-defined-in-Core.Compiler-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-all-Methods-of-functions-defined-in-Core.Compiler" title="Permalink"></a></h3><p><code>visit</code> also descends into functions, methods, and MethodInstances:</p><pre><code class="language-julia-repl hljs">julia&gt; meths = []
Any[]

julia&gt; visit(Core.Compiler) do item
           isa(item, Method) &amp;&amp; push!(meths, item)
           true   # walk through everything
       end

julia&gt; first(methods(Core.Compiler.typeinf_ext)) ∈ meths
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Methods are found by visiting the function. This has an important consequence: if <code>PkgB</code> defines a new method for <code>PkgA.f</code>, you won&#39;t find that method by visiting <code>PkgB</code>: you have to visit <code>PkgA.f</code> (which you can find by visiting <code>PkgA</code>). This is a consequence of how Julia stores Methods, not a limitation of MethodAnalysis.</p><p>Thus, to find all methods defined in <code>PkgB</code>, you have to traverse the entire system (<code>visit() do ... end</code>), and check the <code>meth.module</code> field of every Method to determine which module created it.</p><p>For methods that accept keyword arguments, Julia creates &quot;hidden&quot; methods for filling in the default values. Prior to Julia 1.9, you could find these by visiting the module that owns the &quot;parent&quot; function. On Julia 1.9 and above, these instead get added as methods of <code>Core.kwcall</code>. Consequently, these methods cannot be found by visiting the module that owns the parent function.</p></div></div><h3 id="Getting-a-MethodInstance-for-a-particular-set-of-types"><a class="docs-heading-anchor" href="#Getting-a-MethodInstance-for-a-particular-set-of-types">Getting a MethodInstance for a particular set of types</a><a id="Getting-a-MethodInstance-for-a-particular-set-of-types-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-a-MethodInstance-for-a-particular-set-of-types" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; foo(::AbstractVector) = 1
foo (generic function with 1 method)

julia&gt; methodinstance(foo, (Vector{Int},))   # we haven&#39;t called it yet, so it&#39;s not compiled


julia&gt; foo([1,2])
1

julia&gt; methodinstance(foo, (Vector{Int},))
MethodInstance for foo(::Vector{Int64})</code></pre><h3 id="Collecting-a-subset-of-MethodInstances-for-a-particular-function"><a class="docs-heading-anchor" href="#Collecting-a-subset-of-MethodInstances-for-a-particular-function">Collecting a subset of MethodInstances for a particular function</a><a id="Collecting-a-subset-of-MethodInstances-for-a-particular-function-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-a-subset-of-MethodInstances-for-a-particular-function" title="Permalink"></a></h3><p>Let&#39;s collect all single-argument compiled instances of <code>findfirst</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; mis = Core.MethodInstance[];

julia&gt; visit(findfirst) do item
           isa(item, Core.MethodInstance) &amp;&amp; length(Base.unwrap_unionall(item.specTypes).parameters) == 2 &amp;&amp; push!(mis, item)
           true
       end

julia&gt; mis
1-element Vector{Core.MethodInstance}:
 MethodInstance for findfirst(::BitVector)</code></pre><p>We checked that the length was 2, rather than 1, because the first parameter is the function type itself:</p><pre><code class="language-julia-repl hljs">julia&gt; mis[1].specTypes
Tuple{typeof(findfirst), BitVector}</code></pre><p>There&#39;s also a convenience shortcut:</p><pre><code class="language-julia hljs">julia&gt; mis = methodinstances(findfirst)</code></pre><h3 id="Getting-the-backedges-for-a-function"><a class="docs-heading-anchor" href="#Getting-the-backedges-for-a-function">Getting the backedges for a function</a><a id="Getting-the-backedges-for-a-function-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-the-backedges-for-a-function" title="Permalink"></a></h3><p>Let&#39;s see all the compiled instances of <code>Base.setdiff</code> and their immediate callers:</p><pre><code class="language-julia-repl hljs">julia&gt; direct_backedges(setdiff)
6-element Vector{Any}:
     MethodInstance for setdiff(::Base.KeySet{Any, Dict{Any, Any}}, ::Base.KeySet{Any, Dict{Any, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Dict{Any, Any})
     MethodInstance for setdiff(::Base.KeySet{Any, Dict{Any, Any}}, ::Base.KeySet{Any, Dict{Any, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Union{Dict{Any, Any}, Dict{Char, Any}})
   MethodInstance for setdiff(::Base.KeySet{Char, Dict{Char, Any}}, ::Base.KeySet{Any, Dict{Any, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Union{Dict{Any, Any}, Dict{Char, Any}})
   MethodInstance for setdiff(::Base.KeySet{Any, Dict{Any, Any}}, ::Base.KeySet{Char, Dict{Char, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Union{Dict{Any, Any}, Dict{Char, Any}})
 MethodInstance for setdiff(::Base.KeySet{Char, Dict{Char, Any}}, ::Base.KeySet{Char, Dict{Char, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Union{Dict{Any, Any}, Dict{Char, Any}})
                                   MethodInstance for setdiff(::Vector{Base.UUID}, ::Vector{Base.UUID}) =&gt; MethodInstance for deps_graph(::Pkg.Types.Context, ::Dict{Base.UUID, String}, ::Dict{Base.UUID, Pkg.Types.VersionSpec}, ::Dict{Base.UUID, Pkg.Resolve.Fixed})</code></pre><h3 id="Printing-backedges-as-a-tree"><a class="docs-heading-anchor" href="#Printing-backedges-as-a-tree">Printing backedges as a tree</a><a id="Printing-backedges-as-a-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Printing-backedges-as-a-tree" title="Permalink"></a></h3><p>MethodAnalysis uses <a href="https://github.com/JuliaCollections/AbstractTrees.jl">AbstractTrees</a> to display the complete set of backedges:</p><pre><code class="language-julia-repl hljs">julia&gt; mi = methodinstance(findfirst, (BitVector,))
MethodInstance for findfirst(::BitVector)

julia&gt; MethodAnalysis.print_tree(mi)
MethodInstance for findfirst(::BitVector)
├─ MethodInstance for prune_graph!(::Graph)
│  └─ MethodInstance for var&quot;#simplify_graph!#111&quot;(::Bool, ::typeof(simplify_graph!), ::Graph, ::Set{Int64})
│     └─ MethodInstance for simplify_graph!(::Graph, ::Set{Int64})
│        └─ MethodInstance for simplify_graph!(::Graph)
│           ├─ MethodInstance for trigger_failure!(::Graph, ::Vector{Int64}, ::Tuple{Int64, Int64})
│           │  ⋮
│           │
│           └─ MethodInstance for resolve_versions!(::Context, ::Vector{PackageSpec})
│              ⋮
│
├─ MethodInstance for update_solution!(::SolutionTrace, ::Graph)
│  └─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
│     ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
│     │  ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
│     │  │  ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
│     │  │  │  ⋮
│     │  │  │
│     │  │  └─ MethodInstance for maxsum(::Graph)
│     │  │     ⋮
│     │  │
│     │  └─ MethodInstance for maxsum(::Graph)
│     │     └─ MethodInstance for resolve(::Graph)
│     │        ⋮
│     │
│     └─ MethodInstance for maxsum(::Graph)
│        └─ MethodInstance for resolve(::Graph)
│           ├─ MethodInstance for trigger_failure!(::Graph, ::Vector{Int64}, ::Tuple{Int64, Int64})
│           │  ⋮
│           │
│           └─ MethodInstance for resolve_versions!(::Context, ::Vector{PackageSpec})
│              ⋮
│
└─ MethodInstance for selective_eval_fromstart!(::typeof(finish_and_return!), ::Frame, ::BitVector, ::Bool)
   └─ MethodInstance for selective_eval_fromstart!(::Frame, ::BitVector, ::Bool)</code></pre><h3 id="Finding-the-callers-of-a-method"><a class="docs-heading-anchor" href="#Finding-the-callers-of-a-method">Finding the callers of a method</a><a id="Finding-the-callers-of-a-method-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-the-callers-of-a-method" title="Permalink"></a></h3><p>To find already-compiled callers of <code>sum(::Vector{Int})</code></p><pre><code class="language-julia hljs"># Collect all MethodInstances
mis = methodinstances();
# Create a function that returns `true` for the correct set of argument types
argmatch(argtyps) = length(argtyps) == 1 &amp;&amp; argtyps[1] === Vector{Int}
# Find the calls that match
findcallers(sum, argmatch, mis)</code></pre><p>There are more options, see the help for <code>findcallers</code>.</p><h2 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h2><h3 id="visit"><a class="docs-heading-anchor" href="#visit">visit</a><a id="visit-1"></a><a class="docs-heading-anchor-permalink" href="#visit" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.visit" href="#MethodAnalysis.visit"><code>MethodAnalysis.visit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visit(operation, obj; print::Bool=false)</code></pre><p>Scan <code>obj</code> and all of its &quot;sub-objects&quot; (e.g., functions if <code>obj::Module</code>, methods if <code>obj::Function</code>, etc.) recursively. <code>operation(x)</code> should return <code>true</code> if <code>visit</code> should descend into &quot;sub-objects&quot; of <code>x</code>.</p><p>If <code>print</code> is <code>true</code>, each visited object is printed to standard output.</p><p><strong>Example</strong></p><p>To collect all MethodInstances of a function,</p><pre><code class="language-julia-repl hljs">julia&gt; mis = Core.MethodInstance[];

julia&gt; visit(findfirst) do x
           if isa(x, Core.MethodInstance)
               push!(mis, x)
               return false
           end
           true
       end

julia&gt; length(mis)
34</code></pre><p>The exact number of MethodInstances will depend on what code you&#39;ve run in your Julia session.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/visit.jl#LL1-L31">source</a></section><section><div><pre><code class="nohighlight hljs">visit(operation; print::Bool=false)</code></pre><p>Scan all loaded modules with <code>operation</code>. See <a href="#MethodAnalysis.visit"><code>visit(operation, obj)</code></a> for further detail.</p><p><strong>Example</strong></p><p>Collect all loaded modules, even if they are internal.</p><pre><code class="language-julia-repl hljs">julia&gt; mods = Module[];

julia&gt; visit() do x
           if isa(x, Module)
               push!(mods, x)
               return true
           end
           false
       end</code></pre><p>julia&gt; mods 113-element Array{Module,1}:  Random  Random.DSFMT [...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/visit.jl#LL35-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.visit_backedges" href="#MethodAnalysis.visit_backedges"><code>MethodAnalysis.visit_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visit_backedges(operation, obj)</code></pre><p>Visit the backedges of <code>obj</code> and apply <code>operation</code> to each. <code>operation</code> may need to be able to handle two call forms, <code>operation(mi)</code> and <code>operation(sig=&gt;mi)</code>, where <code>mi</code> is a <code>MethodInstance</code> and <code>sig</code> is a <code>Tuple</code>-type. The latter arises from either <code>invoke</code> calls or <code>MethodTable</code> backedges.</p><p><code>operation(edge)</code> should return <code>true</code> if the backedges of <code>edge</code> should in turn be visited, <code>false</code> otherwise. However, no <code>MethodInstance</code> will be visited more than once.</p><p>The set of visited objects includes <code>obj</code> itself. For example, <code>visit_backedges(operation, f::Function)</code> will visit all methods of <code>f</code>, and this in turn will visit all MethodInstances of these methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/visit.jl#LL228-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.visit_withmodule" href="#MethodAnalysis.visit_withmodule"><code>MethodAnalysis.visit_withmodule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visit_withmodule(operation; print::Bool=false)
visit_withmodule(operation, obj, mod; print::Bool=false)</code></pre><p>Similar to <a href="#MethodAnalysis.visit"><code>visit</code></a>, except that <code>operation</code> should have signature <code>operation(x, mod)</code> where <code>mod</code> is either:</p><ul><li>the module in which <code>x</code> was found, or</li><li><code>nothing</code> if <code>x</code> is itself a top-level module.</li></ul><p>If you&#39;re visiting underneath a specific object <code>obj</code>, you must supply <code>mod</code>, the module (or <code>nothing</code>) in which <code>obj</code> would be found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/visit.jl#LL80-L91">source</a></section></article><h3 id="backedges"><a class="docs-heading-anchor" href="#backedges">backedges</a><a id="backedges-1"></a><a class="docs-heading-anchor-permalink" href="#backedges" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.all_backedges" href="#MethodAnalysis.all_backedges"><code>MethodAnalysis.all_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_backedges(mi::MethodInstance)</code></pre><p>Return a list of all backedges (direct and indirect) of <code>mi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/backedges.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.direct_backedges" href="#MethodAnalysis.direct_backedges"><code>MethodAnalysis.direct_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">direct_backedges(f::Function; skip=true)</code></pre><p>Collect all backedges for a function <code>f</code> as pairs <code>instance=&gt;caller</code> or <code>sig=&gt;caller</code> pairs. The latter occur for MethodTable backedges. If <code>skip</code> is <code>true</code>, any <code>caller</code> listed in a MethodTable backedge is omitted from the instance backedges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/backedges.jl#LL50-L56">source</a></section><section><div><pre><code class="nohighlight hljs">direct_backedges(mi::MethodInstance)</code></pre><p>A vector of all direct backedges of <code>mi</code>. This is equivalent to <code>mi.backedges</code> except that it&#39;s &quot;safe,&quot; meaning it returns an empty list even when <code>mi.backedges</code> is not defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/backedges.jl#LL101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.terminal_backedges" href="#MethodAnalysis.terminal_backedges"><code>MethodAnalysis.terminal_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">terminal_backedges(mi::MethodInstance)</code></pre><p>Obtain the &quot;ultimate callers&quot; of <code>mi</code>, i.e., the reason(s) <code>mi</code> was compiled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/backedges.jl#LL33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.with_all_backedges" href="#MethodAnalysis.with_all_backedges"><code>MethodAnalysis.with_all_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">with_all_backedges(itr)</code></pre><p>Return all MethodInstances detected when iterating through items in <code>itr</code> and any their backedges. The result includes both MethodTable and MethodInstance backedges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/backedges.jl#LL13-L18">source</a></section></article><h3 id="utilities"><a class="docs-heading-anchor" href="#utilities">utilities</a><a id="utilities-1"></a><a class="docs-heading-anchor-permalink" href="#utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.methodinstance" href="#MethodAnalysis.methodinstance"><code>MethodAnalysis.methodinstance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mi = methodinstance(f, types)
mi = methodinstance(tt::Type{&lt;:Tuple})</code></pre><p>Return the <code>MethodInstance</code> <code>mi</code> for function <code>f</code> and the given <code>types</code>, or for the complete signature <code>tt</code>. If no version compiled for these types exists, returns <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x, y::String) = 2x; f(x, y::Number) = x + y;

julia&gt; f(1, &quot;hi&quot;); f(1, 1.0);

julia&gt; methodinstance(f, (Int, String))
MethodInstance for f(::Int64, ::String)

julia&gt; methodinstance(Tuple{typeof(f), Int, String})
MethodInstance for f(::Int64, ::String)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/MethodAnalysis.jl#LL84-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.methodinstances" href="#MethodAnalysis.methodinstances"><code>MethodAnalysis.methodinstances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">methodinstances()
methodinstances(top)</code></pre><p>Collect all <code>MethodInstance</code>s, optionally restricting them to a particular module, function, method, or methodlist.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; sin(π/2)
1.0

julia&gt; sin(0.8f0)
0.7173561f0

julia&gt; methodinstances(sin)
2-element Vector{Core.MethodInstance}:
 MethodInstance for sin(::Float64)
 MethodInstance for sin(::Float32)

julia&gt; m = which(convert, (Type{Bool}, Real))
convert(::Type{T}, x::Number) where T&lt;:Number in Base at number.jl:7

julia&gt; methodinstances(m)
68-element Vector{Core.MethodInstance}:
 MethodInstance for convert(::Type{UInt128}, ::Int64)
 MethodInstance for convert(::Type{Int128}, ::Int64)
 MethodInstance for convert(::Type{Int64}, ::Int32)
 MethodInstance for convert(::Type{UInt64}, ::Int64)
 ⋮</code></pre><p>Note the method <code>m</code> was broader than the signature we queried with, and the returned <code>MethodInstance</code>s reflect that breadth. See <a href="#MethodAnalysis.methodinstances"><code>methodinstances</code></a> for a more restrictive subset, and <a href="#MethodAnalysis.methodinstances_owned_by"><code>methodinstances_owned_by</code></a> for collecting MethodInstances owned by specific modules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/MethodAnalysis.jl#LL135-L170">source</a></section><section><div><pre><code class="nohighlight hljs">methodinstances(f, types)
methodinstances(tt::Type{&lt;:Tuple})</code></pre><p>Return all MethodInstances whose signature is a subtype of <code>types</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; methodinstances(convert, (Type{Bool}, Real))
2-element Vector{Core.MethodInstance}:
 MethodInstance for convert(::Type{Bool}, ::Bool)
 MethodInstance for convert(::Type{Bool}, ::Int64)</code></pre><p>Compare this to the result from <a href="#MethodAnalysis.methodinstance"><code>methodinstance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/MethodAnalysis.jl#LL184-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.methodinstances_owned_by" href="#MethodAnalysis.methodinstances_owned_by"><code>MethodAnalysis.methodinstances_owned_by</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mis = methodinstances_owned_by(mod::Module; include_child_modules::Bool=true, kwargs...)</code></pre><p>Return a list of <code>MethodInstance</code>s that are owned by <code>mod</code>. If <code>include_child_modules</code> is <code>true</code>, this includes sub-modules of <code>mod</code>, in which case <code>kwargs</code> are passed to <a href="#MethodAnalysis.child_modules"><code>child_modules</code></a>.</p><p>The primary difference between <code>methodinstances(mod)</code> and <code>methodinstances_owned_by(mod)</code> is that the latter excludes <code>MethodInstances</code> that belong to re-exported dependent packages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/MethodAnalysis.jl#LL279-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.child_modules" href="#MethodAnalysis.child_modules"><code>MethodAnalysis.child_modules</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mods = child_modules(mod::Module; external::Bool=false)</code></pre><p>Return a list that includes <code>mod</code> and all sub-modules of <code>mod</code>. By default, modules loaded from other sources (e.g., packages or those defined by Julia itself) are excluded, even if exported (or <code>@reexport</code>ed, see https://github.com/simonster/Reexport.jl), unless you set <code>external=true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; module Outer
       module Inner
       export Base
       end
       end
Main.Outer

julia&gt; child_modules(Outer)
2-element Vector{Module}:
 Main.Outer
 Main.Outer.Inner

julia&gt; child_modules(Outer.Inner)
1-element Vector{Module}:
 Main.Outer.Inner</code></pre><p><strong>Extended help</strong></p><p>In the example above, because of the <code>export Base</code>, the following <code>visit</code>-based implementation would also collect <code>Base</code> and all of its sub-modules:</p><pre><code class="language-julia-repl hljs">julia&gt; mods = Module[]
Module[]

julia&gt; visit(Outer) do item
           if item isa Module
               push!(mods, item)
               return true
           end
           return false
       end

julia&gt; Base ∈ mods
true

julia&gt; length(mods) &gt; 20
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/MethodAnalysis.jl#LL209-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.call_type" href="#MethodAnalysis.call_type"><code>MethodAnalysis.call_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">call_type(tt)</code></pre><p>Split a signature type like <code>Tuple{typeof(f),ArgTypes...}</code> back out to <code>(f, Tuple{ArgTypes...})</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/MethodAnalysis.jl#LL35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.findcallers" href="#MethodAnalysis.findcallers"><code>MethodAnalysis.findcallers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">callers = findcallers(f, argmatch::Union{Nothing,Function}, mis; callhead=:call | :iterate)</code></pre><p>Find &quot;static&quot; callers of a function <code>f</code> with <em>inferred</em> argument types for which <code>argmatch(types)</code> returns true. Optionally pass <code>nothing</code> for <code>argmatch</code> to allow any calls to <code>f</code>. <code>mis</code> is the list of <code>MethodInstance</code>s you want to check, for example obtained from <a href="#MethodAnalysis.methodinstances"><code>methodinstances</code></a>.</p><p><code>callhead</code> controls whether you&#39;re looking for an ordinary (<code>:call</code>) or a splatted (varargs) call (<code>:iterate</code>).</p><p><code>callers</code> is a vector of <a href="#MethodAnalysis.CallMatch"><code>CallMatch</code></a> objects.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f(x) = rand()
function g()
    a = f(1.0)
    z = Any[7]
    b = f(z[1]::Integer)
    c = f(z...)
    return nothing
end

g()
mis = union(methodinstances(f), methodinstances(g))

# callhead = :call is the default
callers1 = findcallers(f, argtyps-&gt;length(argtyps) == 1 &amp;&amp; argtyps[1] === Float64, mis)

# Get the partial-inference case with known number of arguments (this is definitely :call)
callers2 = findcallers(f, argtyps-&gt;length(argtyps) == 1 &amp;&amp; argtyps[1] === Integer, mis; callhead=:call)

# Get the splat call
callers3 = findcallers(f, argtyps-&gt;length(argtyps) == 1 &amp;&amp; argtyps[1] === Vector{Any}, mis; callhead=:iterate)</code></pre><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p><code>findcallers</code> is available on Julia 1.6 and higher</p></div></div><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p><code>findcallers</code> is not guaranteed to find all calls. Calls can be &quot;obfuscated&quot; by many mechanisms, including calls from top level, calls where the function is a runtime variable, etc.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/findcallers.jl#LL55-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.hasbox" href="#MethodAnalysis.hasbox"><code>MethodAnalysis.hasbox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hasbox(mi::MethodInstance)</code></pre><p>Return <code>true</code> if the code for <code>mi</code> has a <code>Core.Box</code>. This often arises from a limitation in Julia&#39;s type-inference, see https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/MethodAnalysis.jl#LL315-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.worlds" href="#MethodAnalysis.worlds"><code>MethodAnalysis.worlds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minmaxs = worlds(mi::MethodInstance)</code></pre><p>Collect the (min,max) world-age pairs for all CodeInstances associated with <code>mi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/MethodAnalysis.jl#LL47-L51">source</a></section></article><h3 id="types"><a class="docs-heading-anchor" href="#types">types</a><a id="types-1"></a><a class="docs-heading-anchor-permalink" href="#types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.CallMatch" href="#MethodAnalysis.CallMatch"><code>MethodAnalysis.CallMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CallMatch</code></pre><p>A structure to summarize a &quot;matching&quot; caller/callee pair. The fields are:</p><ul><li><code>mi</code>: the <code>MethodInstance</code> for the caller</li><li><code>src</code>: its corresponding <code>CodeInfo</code></li><li><code>sparams</code>: the type parameters for the caller, given <code>mi</code>&#39;s signature (alternatively use <code>mi.sparam_vals</code>)</li><li><code>line</code>: the statement number (in SSAValue sense) on which the call occurs</li><li><code>argtypes</code>: the caller&#39;s inferred types passed as arguments to the callee</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/27a263fba41f145f6482ba9386878786ac03bd43/src/findcallers.jl#LL32-L42">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 2 April 2023 08:25">Sunday 2 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
